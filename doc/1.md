# 设计思路

## 事件设置

程序由4个基本事件构成

1. 顾客到达
2. 开始服务
3. 结束服务
4. 顾客离队

#### 顾客到达事件
- 检查是否有空闲理发师和椅子。
- 如果有空闲，分配理发师和椅子给顾客，生成开始理发事件并加入事件队列。
- 如果没有空闲，将顾客加入等待队列，并生成离队事件。

#### 开始服务事件
- 分配理发师和椅子给顾客，更新状态为“忙碌”。
- 计算理发结束时间
- 生成理发完成事件，并加入优先队列。

#### 结束服务事件
- 释放理发师和椅子，更新状态为“空闲”。
- 检查等待队列中是否有其他顾客。
- 从等待队列中取出下一个顾客，生成开始服务事件，并将其加入优先队列。
- 更新统计数据，如理发师的工作时间和创收

#### 顾客离队事件
- 检查顾客是否仍在等待队列中。
- 如果顾客在等待队列中，将其移出队列，更新统计数据


## 结构设计

### `Id`类
- 用于标识唯一的对象，作为`book marking`的键
- 派生出用于标识椅子，顾客和理发师的id类

### `ServiceLevel`
- ABTY, S1, S2, S3

### `Customer`
- id
- ServiceLevel
- 消耗时间系数
- 到达时间戳
- 最长等待时间

### `Barber`
- id
- opt:CustomerId   #如果为空，表示理发师空闲
- ServiceLevel
- 消耗时间系数
- 总工作时间

### `Chair`
- id
- opt:pair:BarberId, CustomerId    #如果为空，表示空闲

## 全局变量

### `tick`
- 流逝时间

### `mainEvent`
- 储存事件的优先队列

### `serviceLevelMetrics`
- 分别为各个ServiceLevel提供和记录各种信息
- 提供：基准服务时长，收费标准
- 记录：收入，服务时长

### `xxxEntryRegistry`
- 用于记录所有的理发师，顾客和椅子
- 使用unordered_map映射，key为id, 提供对应的hash函数

### `emptyEntry`
- 每个键为ServiceLevel
- 每个值为理发师或椅子的空闲集合

### `customerQueTable`
- 不同的Service顾客等待队列



## 杂项
2. 输出可以输出到文件，然后使用tail监视
3. 
